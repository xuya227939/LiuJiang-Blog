# 垃圾回收机制（GC）

## 可达性（Reachability）

JavaScript 中主要的内存管理概念是 可达性。

简而言之，“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。

这里列出固有的可达值的基本集合，这些值明显不能被释放。

比方说：

-   当前函数的局部变量和参数。
-   嵌套调用时，当前调用链上所有函数的变量与参数。
-   全局变量。
-   （还有一些内部的）

这些值被称作 根（roots）。

如果一个值可以通过引用或引用链从根访问任何其他值，则认为该值是可达的。

比方说，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则 该 对象被认为是可达的。而且它引用的内容也是可达的。下面是详细的例子。

在 JavaScript 引擎中有一个被称作 垃圾回收器 的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的。

## 内存生命周期

内存也是有生命周期的，不管什么程序语言，一般可以按顺序分为三个周期：

-   分配期
    分配所需要的内存

-   使用期
    使用分配到的内存（读、写）

-   释放期
    不需要时将其释放和归还

内存分配 -> 内存使用 -> 内存释放。

## 什么是内存泄漏？

> 在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。

## 内存分配

```
// 给数值变量分配内存
const number = 123;
// 给字符串分配内存
const string = "xianshannan";
// 给对象及其包含的值分配内存
const object = {
    a: 1,
    b: null
};
// 给数组及其包含的值分配内存（就像对象一样）
const array = [1, null, "abra"];
// 给函数（可调用的对象）分配内存
function func(a) {
    return a;
}
```

## 内存使用

> 使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。

## 内存回收

> 前端界一般称垃圾内存回收为 GC（Garbage Collection，即垃圾回收）。

内存泄漏一般都是发生在这一步，JavaScript 的内存回收机制虽然能回收绝大部分的垃圾内存，但是，还是存在回收不了的情况，如果存在这些情况，需要我们手动清理内存。

### 引用计数垃圾收集

> 这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

#### 优点

-   可即刻回收垃圾
-   最大暂停时间短
-   没有必要沿指针查找， 不要和标记-清除算法一样沿着根集合开始查找

#### 缺点

-   计数器的增减处理繁重
-   计数器需要占用很多位
-   实现繁琐复杂， 每个赋值操作都得替换成引用更新操作
-   循环引用无法回收

### 标记清除法

> 当变量进入执行环境时标记为“进入环境”，当变量离开执行环境时则标记为“离开环境”，被标记为“进入环境”的变量是不能被回收的，因为它们正在被使用，而标记为“离开环境”的变量则可以被回收

```
// 假设这里是全局变量
// b 被标记进入环境
var b = 2;
function test() {
    var a = 1;
    // 函数执行时，a 被标记进入环境
    return a + b;
}
// 函数执行结束，a 被标记离开环境，被回收
// 但是 b 就没有被标记离开环境
test();
```

#### 内部算法

垃圾回收的基本算法被称为 “mark-and-sweep”。

定期执行以下“垃圾回收”步骤：

-   垃圾收集器找到所有的根，并“标记”（记住）它们。
-   然后它遍历并“标记”来自它们的所有引用。
-   然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。
-   ……如此操作，直到所有可达的（从根部）引用都被访问到。
-   没有被标记的对象都会被删除。

#### 优点

实现简单， 容易和其他算法组合

#### 缺点

-   碎片化， 会导致无数小分块散落在堆的各处
-   分配速度不理想，每次分配都需要遍历空闲列表找到足够大的分块
-   与写时复制技术不兼容，因为每次都会在活动对象上打上标记

### 代际假说

代际假说（The Generational Hypothesis）是垃圾回收领域中的一个重要术语， V8 的垃圾回收的策略也是建立在该假说的基础之上。
代际假说也很简单，主要有两个特点：

-   大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问。

-   不死的对象，会活的更久。

基于这个这个假说 V8 才会把堆分为新生代和老生代两个区域，同时设计了两个垃圾回收器：

副垃圾回收器 负责新生代区域的垃圾回收
主垃圾回收器 负责老生代区域的垃圾回收

## v8 的垃圾回收机制

采用了分代式垃圾回收机制。V8 将内存（堆）分为新生代和老生代两部分。

### 新生代算法

> 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁。在新生代分配内存非常容易，我们只需要保存一个指向内存区的指针，不断根据新对象的大小进行递增即可。当该指针到达了新生代内存区的末尾，就会有一次清理（仅仅是清理新生代）在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了

### 老生代算法

> 老生代所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多，老生代中的垃圾回收策略是 Mark-Sweep（标记清除）和 Mark-Compact（标记整理）相结合。
